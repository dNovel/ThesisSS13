\documentclass[pagesize, paper=a4, fontsize=12pt,titlepage=true, headings=small, headnosepline, abstractoff, liststotoc, nochapterprefix, plainheadsepline]{scrreprt}
\usepackage[a4paper, left=40mm, right=30mm, top=20mm, bottom=20mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{setspace}
\usepackage{color}
\usepackage{cite} % Paket fuer die Zitation
%\usepackage{sourcesanspro}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
% Bilder Settings
\usepackage{graphicx}
\usepackage [singlelinecheck=false] {caption}
\usepackage{subcaption}

% Paket fuer das anzeigen von Quellcode
\usepackage{listings}
% Setze die Programmiersprache auf CSharp
\lstset{language=[Sharp]C} 

% Festlegung Art der Zitierung - Havardmethode: Abkuerzung Autor + Jahr
\bibliographystyle{plain}

% Festlegen der Sprache
\selectlanguage{german}

% Settings fuer den Sourcecode START
\definecolor{mygreen}{rgb}{0,0.4,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{bggray}{rgb}{0.97,0.97,0.97}
\definecolor{titlegray}{rgb}{0.45,0.45,0.45}

% Farbe für die Überschriften
\addtokomafont{sectioning}{\color{titlegray}\rmfamily}


\lstset{
backgroundcolor=\color{bggray},  % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\scriptsize, % the size of the fonts that are used for the code
breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
breaklines=true,                 % sets automatic line breaking
captionpos=b,                    % sets the caption-position to bottom
commentstyle=\color{mygreen},    % comment style
deletekeywords={...},            % if you want to delete keywords from the given language
escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single,                    % adds a frame around the code
keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue},       % keyword style
language=[Sharp]C,                 % the language of the code
morekeywords={*,Select},            % if you want to add more keywords to the set
numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt,                   % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false,          % underline spaces within strings only
showtabs=false,                  % show tabs within strings adding particular underscores
stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve},     % string literal style
tabsize=2,                       % sets default tabsize to 2 spaces
title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
captionpos=t,
aboveskip=0.5\baselineskip,		% Platz über dem quellcode block
belowskip=2\baselineskip,			% Platz unter dem quellcode block
%morecomment=[il]{///}
}
% Settings fuer den Sourcecode ENDE


% Autoren
\author{
Dominik Steffen \and
Erstbetreuer: Prof. Christoph Müller, Fakultät DM \and
Zweitbetreuer: Prof. Wilhelm Walter, Fakultät DM
}


% Titel
\title{LINQ for Geometry}
\subtitle{Implementierung der Half-Edge Datenstruktur zu Manipulation und Handling Dreidimensionaler Meshes insbesondere durch den Einsatz von LINQ und LAMBA Ausdrücken in Microsofts \CS}

\parindent 0pt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Commands START - Makros
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% C# makro OHNE space nach dem logo
\newcommand{\CS}{C\texttt{\#}}
% C# makro MIT space nach dem logo
\newcommand{\CSS}{C\texttt{\# }}
% C++ Logo
\newcommand{\CPP}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
% LINQ For Geometry
\newcommand{\LFG}{LINQ For Geometry}
% LINQ For Geometry mit Space
\newcommand{\LFGS}{LINQ For Geometry }
% LINQ mit spaces links und rechts
\newcommand{\LQ}{ LINQ }
% Generic zeichen <T>
\newcommand{\GT}{\textless T\textgreater}
\newcommand{\GTS}{\textless T\textgreater\space}
% Lambda Zeichen in C#
\newcommand{\LAM}{ =\textgreater\space}
% HES
\newcommand{\HES}{Half-Edge Datenstruktur }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Commands ENDE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Unterstrichene Kapitelüberschriften START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*{\ORIGchapterheadendvskip}{}%
\let\ORIGchapterheadendvskip=\chapterheadendvskip
\renewcommand*{\chapterheadendvskip}{%
\ORIGchapterheadendvskip
{%
\setlength{\parskip}{0pt}%
\noindent\rule[3\baselineskip]{\linewidth}{1pt}\par
}%
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Unterstrichene Kapitelüberschriften ENDE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeindex
\onehalfspacing

\begin{document}
% Titelblatt START
\maketitle
% Titelblatt ENDE

% Inhaltsverzeichnis START
\begingroup
	\clearpage
	\pagestyle{empty}
	\renewcommand*{\chapterpagestyle}{empty}
	\tableofcontents
	\clearpage
\endgroup
% Inhaltsverzeichnis ENDE

% Passe Seitenzahlen wieder an START
\pagestyle{plain}
\setcounter{page}{1}
% Passe Seitenzahlen wieder an ENDE


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inhalt START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%
% Strukturierung der Thesis in vorläufiger Form
%%%%%%%%%%



%%%%%%
%	Einführung / Einleitung START
%%%%%%

\chapter {Einleitung}
	\section {Fragestellung}
		%Ist es möglich die „Half-Edge Data Structure“ (kurz HES) in einer gemanagten Programmiersprache wie \CSS unter der Berücksichtigung von LINQ und Lambda Ausdrücken so zu implementueren, dass damit grundlegende Geometriemanipulation in der Computergrafik erfolgen kann?
Ist eine Implementierung der Half-Edge Datenstruktur in \CSS unter Berücksichtigung von\LQ und Lambda Support möglich?
	\section {Anforderungen und Ziele}
	%Content
	
	%Content
	\section {Allgemeines zur \HES}
		%Content
		% Mark de Berg, Otfried Cheong, Marc van Kreveld, Mark Overmars: Computational Geometry: Algorithms and Applications.
		%Springer-Verlag Berlin Heidelberg New York, 2000, ISBN 3-540-65620-0, S. 31–32 und 33
		Die Half-Edge Datenstruktur, oft auch als Doubly-connected edge list bezeichnet, ist eine Datenstruktur welche haupts"achlich in der Computergrafik eingesetzt wird. Sie ist sehr flexibel und kann z.B. benutzt werden um topologische und strukutrelle Informationen in Landkarten zu speichern. Diese Arbeit setzt die \HES dazu ein die wichtigsten Informationen eines dreidimensionalen Computermodells zu repr"asentieren und sie f"ur eine sp"atere Verwendung im Speicher bereit zu halten. Sehr oft werden Informationen eines Computermodells ohne relationale Verbindungen gespeichert. Bei diesen so genannten Face basierten Datenstrukturen handelt es sich um sehr einfache Datenstrukturen zur Speicherung die keinen gro"sen Spielraum f"ur Optimierungen und erweiterungen lassen. Bei Iterationen und geometrischen Manipulationen sind Face basierte Strukturen wesentlich langsamer (dazu sp"ater mehr) und werden meist nicht f"ur geometrische Operationen sondern nur zum speichern der Daten im Prim"ar oder Sekund"arspeicher des Rechners verwendet. Die \HES wird f"ur dieses Projekt sogar ein wenig bez"uglich ihres Umfangs erweitert ohne aber die grunds"atzlichen Gegebenheiten der Datenstruktur zu beeinflussen.

Ein Kernelement der \HES und sicherlich ihre bekannteste und herausragenste Eigenschaft ist, dass jede Kante im gespeicherten Modell (Mesh) als Kombination aus zwei Half-Edges repr"asentiert wird. Zwei Half-Edges zusammen ergeben also eine komplette Kante. In der Implementierung dieses Projektes kommt es nicht vor, dass eine Half-Edge f"ur sich alleine steht.
		\subsection {Die Basis der Half-Edge Datenstruktur und Unterschiede zur Doubly-connected edge list}
			%Content
			%TODO Planare Graphen erkläutern und verstehen
			Im vorigen Abschnitt wurde erw"ahnt, dass die \HES oft auch als Doubly-connected edge list bezeichnet wird. Im Hinblick auf die Implementierung dieser Arbeit ist das so nicht ganz richtig. Dieser Text bezieht sich bei Betrachtung der Doubly-connected edge list immer auf die Darstellung von \cite{vanMarkdeBerg.2008}. Es gibt einige wenige feine Unterschiede der beiden Datenstrukturen die sich in der Implementierung dieses Projekts zu einem sp"ateren Zeitpunkt, nicht "uberm"assig, bemerkbar machen.

Die \HES besteht grunds"atzlich aus vier verschiedenen Datens"atzen (data records). Dazu z"ahlen:
\begin{itemize}
\item Vertex, Punkt im dreidimensionalen Raum der um zus"atzliche Informationen erweitert wurde. 
\item Face, zu betrachten als Polygon (Geometrische Figur mit mehr als 3 Eckpunkten) mit zus"atzlichen gespeicherten Informationen
\item Half-Edge, der wichtigste Datensatz in der Datenstruktur, eine halbe Kante welche in der \HES die meisten Informationen "uber ein dreidimensionales Modell (Mesh) enth"alt.
\item Edge, eine Kante welche aus zwei Halbkanten besteht.
\end{itemize}

\begin{quote}Jeder Datensatz (Half-Edge, Vertex und Face) der Datenstruktur kann ebenfalls dazu benutzen werden Informationen zu speichern welche nicht im direkten Zusammenhang mit den Geometrischen Informationen des Meshes stehen. Es ist in etwa m"oglich, Informationen zur Beleuchtungsberechnung (Vertex- und Facenormalen) oder Textur Koordinaten eines Meshes in den Datens{\dq}atzen zu speichern. Diese zus"atzlichen Informationen werden im folgenden als Attributs-Informationen bezeichnet. \cite[S.~31]{vanMarkdeBerg.2008}\end{quote}

Zu beachten ist hierbei, dass das wichtigste Element der Datenstruktur, die Half-Edge, als gerichtete Kante betrachtet werden sollte.
\begin{quote}In der Half-Edge Datenstruktur sind die Half-Edges Kanten mit einer Orientierung. Der Vertex dem sie entspringen ist dabei als ihr Ursprung zu bezeichnen, w{\"a}hrend der Vertex auf den sie zeigen und auf den sie einen Zeiger enthalten, als Ziel betrachtet wird. \cite[S.~31]{vanMarkdeBerg.2008}\end{quote}

\begin{quote}{\glqq}Because half-edges are oriented we can speak of the \textit{origin }and the \textit{destination }of a half-edge.{\grqq} \cite[S.~31]{vanMarkdeBerg.2008}\end{quote}

			\subsubsection {Doubly Connected Edge List}
				Die doubly connected edge list (kurz DECL) wie in \cite{vanMarkdeBerg.2008} erw"ahnt ist der hier verwendeten \HES "ahnlich. Die Strukturen haben nur ein paar wenige Unterschiede. Zuerst einmal ein paar Worte zu den Gemeinsamkeiten. \begin{quote}Die Doubly-connected edge list besteht grunds{\"a}tzlich ebenfalls aus drei verschiedenen Typen von Datens{\"a}tzen. Dazu z{\"a}hlen, wie auch in der \HES, Vertices, Faces und Half-Edge Datens{\dq}atze. \cite[S.~31]{vanMarkdeBerg.2008}\end{quote}

Somit ist bereits klar, dass sich die Datenstruktur in der Implementierung durch den in diesem Projekt hinzugekommenen data record "`Edge"' unterscheidet. Die Doubly-connected edge list unterscheidet sich weiterhin im Blick auf die Zeiger welche in einem data record gespeichert werden. W"ahrend die hier implementierte \HES in einem Half-Edge record folgende Informationen speichert,
\begin{itemize}
\item Zeiger auf ihre Twin Half-Edge
\item Zeiger auf die n"achste Half-Edge im Uhrzeigersinn (Ist variabel implementierbar. \LFGS implementiert die Zeiger im Uhrzeigersinn)
\item Zeiger auf den Vertex auf den die Half-Edge zeigt
\item Zeiger auf das Face zu welchem die Half-Edge geh"ort
\end{itemize}

speichert die Doubly-connected edge list ein wenig mehr Informationen.
\begin{itemize}
\item Zeiger auf ihre Twin Half-Edge
\item Zeiger auf die n"achste Half-Edge im Uhrzeigersinn
\item Zeiger auf die vorige Half-Edge im Uhrzeigersinn
\item Zeiger auf den Vertex auf den die Half-Edge zeigt
\item Zeiger auf den Vertex von dem die Half-Edge ausgeht
\item Zeiger auf das Face zu welchem die Half-Edge geh"ort
\end{itemize}

Allerdings sind die Quellen hierzu nicht immer Konsistent da beide Datenstrukturen nirgendwo in einer definitiven Form beschrieben werden. So k"onnen sich verschiedene Implementierungen der gleichen Datenstruktur in Feinheiten unterscheiden. Auch die Namensgebung der Doubly-connected edge list und der \HES wird oft synonym benutzt. Das \LFGS Projekt vergleicht hier um einen festen Bezugspunkt zu erhalten also immer die Doubly-connected edge list in der Darstellung von \cite[S.~30 und Folgende]{vanMarkdeBerg.2008} mit der eigenen Implementierung der \HES.

Diese Verbindungen und Beziehungen der data records in der \HES werden im n"achsten Abschnitt genauer erl"autert.

				%Content
			\subsubsection {Verbindungen und Beziehungen in der \HES}
				%Content
				Die \HES bedingt einige Vernetzung unter den einzelnen data records. Es folgt eine Auflistung welche Zeiger jeder der data record enth"alt und eine kurze Skizze zu einem Polygon \ref{pic:polyConnections} und den Beziehungen der darin enthaltenen data records wie sie eine Implementierung der \HES darstellen w"urde.

Hier noch einmal eine Auflistung der einzelnen data records die in der \HES existieren abnehmend sortiert nach ihrem Informationsgehalt.
\begin{itemize}
\item Half-Edge
\item Edge
\item Face
\item Vertex
\end{itemize}

Die Half-Edge ist damit der wichtigste Informationstr"ager in der Datenstruktur. Sie enth"alt als einziges Element Verbindungen zu allen anderen Elementen.
Die folgenden Informationen sind an einer Half-Edge gespeichert.
\begin{itemize}
\item Ein Zeiger auf ihre twin Half-Edge (Der Nachbar der Half-Edge)
\item Ein Zeiger auf den Vertex auf den sie hinf"uhrt
\item Ein Zeiger auf das Face zu dem sie geh"ort
\item Ein Zeiger auf die n"achste Half-Edge im Uhrzeigersinn
\end{itemize}

Eine Edge enth"alt gerade noch zwei Informationen
\begin{itemize}
\item Ein Zeiger auf die erste Half-Edge der Edge
\item Ein Zeiger auf die zweite Half-Edge der Edge
\end{itemize}

Ein Face speichert nur noch eine Information
\begin{itemize}
\item Ein Zeiger auf eine Half-Edge die es begrenzt
\end{itemize}

Der Vertex ebenso eine Information
\begin{itemize}
\item Irgendeine Half-Edge die von ihm ausgeht, dabei wird meist die erste Half-Edge benutzt die an den Vertex angelegt wird
\end{itemize}

\includegraphics[width=\linewidth]{../Bilder/hesBeziehungen}
\captionof{figure}{Diese Illustration zeigt die Verbindung der data records an einem beliebigen Polygon durch Pfeilverbindungen.}\label{pic:polyConnections} 

An dieser Stelle sei bereits vorweg genommen, dass \LFGS in seiner Implementierung diese data records um ein paar Beziehungen, welche durch die Verbindung zur Echtzeit 3D Engine FUSEE n"otig werden, erweitert.

%Content
		\subsection {Vorteile der \HES}
			%Content
			%TODO rasche geschwindigkeit in iterationen. Beispiel für einen Algorithmus anführen der Kanten eines Polygons sucht oder sonstwie über ein Polygon iteriert.
			% Exemplarisch herausfinden wie das Polygon neben einem Würfel heisst das zwischen zwei vertices liegt.
		\subsection {Nachteile der \HES}
			%Content
Es gibt selbst in einer so flexiblen Datenstruktur wie der \HES Nachteile die w"ahrend der Planungsphase oder Implementierung auftreten k"onnen.
			Durch ihren Aufbau und die verschiedenen Verbindung welche w"ahrend einer Initialisierung aufgebaut werden m"ussen ist die Datenstruktur sehr komplex. Es erfordert einiges an Zeit und "Uberlegungen das System f"ur eine Implementierung so zu konstrurieren dass es alle Anforderungen an eine 3D Echtzeitdatenstruktur erf"ullt. Vor einer Implementierung der \HES sollte also gut "uberlegt sein ob sie f"ur das aufkommende Probleme eine vern"unftige L"osung darstellt. In \LFGS ist die Datenstruktur eine sehr eleganze L"osung. Sie ist hinreichend flexibel und gerade noch maximal komplex um eine m"ogliche L"osung f"ur die Problemstellung "`(Editierbare) Echtzeit 3D Datenstruktur"' darzustellen. Es sollte also darauf geachtet werden die \HES nicht als Universall"osung zu betrachten. Wenn ich nur einige wenige Algorithmen oder Operationen auf einem Mesh ausf"uhren m"ochte, so gibt es m"oglicherweise eine effizientere und schnellere Datenstruktur um dies zu bewerkstelligen.

Ein auff"alliger Unterschied zu einfacheren Face basierten Datenstrukturen ist der massiv erh"ohte Overhead der bei der Erstellung der Datenstruktur entsteht. Im n"achsten Abschnitt m"ochte diese Arbeit ein kleines Beispiel vorweisen und exemplarisch den Speicherverbrauch der \HES bestimmen.

\subsubsection {Speicherverbrauch im Gegensatz zu Face basierten Lösungen}
			%Content
			% TODO, höherer verbrauch, aber gleichzeit auch wesentlich flexibler. Speicher ist vorhanden, geschwindigkeit wird gesucht als ziel
			% Vorrechnen eines Beispiels mit beispielhaften Zahlen für ein Mesh und dessen Repräsentierung als HES und als Face based.
			% Zugrund legen eines Würfels mit 6 Seiten, 8 Verts und 12 bzw 24 Kanten.
			Der Overhead der bei der Repr"asentation eines Meshes f"ur eine \HES entsteht ist um einiges h"oher als der Overhead einer Face basierten L"osung. Sollte man also nur einfache Aufgaben auf einem Mesh erledigen wollen oder einige wenige Operationen nur einmal ausf"uhren wollen so w"are es wohl ratsam eine andere Datenstruktur daf"ur zu suchen. Allerdings ist es heute in der Computergrafik meistens so, dass wir gen"ugend Speicherplatz im Prim"arspeicher unserer Rechner und Grafikkarten zur verf"ugung haben um diesen Umstanz zu verschmerzen.
Hier eine Beispielhafte Berechung des Datenverbrauchs.

Man gehe davon aus jedes gespeicherte Element (Daten in Form von Vertices, Faces, Edges, Half-Edges) wird mit 32bit repr"asentiert und jeder Zeiger (Pointer) wird mit 8bit repr"asentiert dann k"onnte man den Speicherverbrauch eines einfachen sechs Seitigen W"urfels wie folgt beschreiben.

So stellt die\HES einen W"urfel dar:
\begin{itemize}
\item 24 Half-Edges jede beansprucht 32 bit
	\begin{enumerate}
    	\item Ein Vertex Pointer mit 8bit
    	\item Ein Twin Pointer mit 8bit
    	\item Ein Next Pointer mit 8bit
    	\item Ein Face Pointer mit 8bit
	\end{enumerate}
\item 12 Edges jede beansprucht 32 bit
	\begin{enumerate}
    	\item Zwei Half-Edge Pointer mit je 8bit
	\end{enumerate}
\item 6 Faces jedes beansprucht 32 bit
	\begin{enumerate}
    	\item Half-Edge Pointer eins mit 8bit
	\end{enumerate}
\item 8 Vertices jeder beansprucht 32 bit
	\begin{enumerate}
    	\item Half-Edge Pointer eins mit 8bit
	\end{enumerate}
\end{itemize}

Daraus w"urden sich nun folgende Berechnungen ergeben:

	Half-Edge Datenmenge: \begin{math}24 * (32bit+ 8bit + 8bit + 8bit + 8bit) = 1536bit\end{math}
	\\
	Edge Datenmenge: \begin{math}12 * (32bit + 8bit + 8bit) = 576bit\end{math}
	\\
	Face Datenmenge: \begin{math}6 * (32bit + 8bit) = 240bit\end{math}
	\\
	Vertex Datenmenge: \begin{math}8 * (32bit + 8bit) = 320bit\end{math}

	In Summe sind das 2672bit = 334 Byte.
\newline

Eine Face basierte L"osung w"urde den W"urfel so darstellen:
\begin{itemize}
\item 6 Faces jedes beansprucht 32 bit
	\begin{enumerate}
    	\item Vier Vertex Pointer mit 8bit pro Face
	\end{enumerate}
\item 8 Vertices jeder beansprucht 32 bit
\end{itemize}

Der Datenverbrauch w"urde wie folgt berechnet:

	Face Datenmenge: \begin{math}6 * (32bit + 8bit + 8bit + 8bit + 8bit) = 384bit\end{math}
	\\
	Vertex Datenmenge: \begin{math}8 * 32bit = 256bit\end{math}

	In Summe sind das 640bit = 80Byte.
\newline

Das Beispiel zeigt also, dass bei einem einfachen Mesh der Speicherverbrauch der \HES um das ca. 4 fache h"oher liegt als der Verbrauch einer Face basierten L"osung. Wie die \HES das aber wieder ausgleicht ist dem Abschnitt "`Vorteile der HES"' zu entnehmen.
	\section {Aktueller Forschungsstatus}
		%Content
		% TODO
		% Erwähnen und einordnen von OpenMesh, zusätzlich noch mal eben recherchieren ob es neue implementierungen der dcel oder der hes gibt welche sich in einer 3d engine oder dergleichen bewegen.
		\subsection {Probleme der aktuellen Forschung}
			%Content
			% TODO
			% Hängt stark vom oberen Abschnitt ab.
	\section {Einführung zu LINQ in \CS}
		%Content
		Language Integrated Query, kurz LINQ und zu deutsch Sprachintegrierte Abfrage, funktioniert ab \CSS 3.0 und ist ein Feature von Microsofts .NET Paket. LINQ ist also ein Produkt von Microsoft und erinnert auf den ersten Blick in seinem syntaktischen und semantischem Aufbau stark an das Open Source Projekt MySQL welches aktuell (Stand Juli 2013) von der Oracle Corporation betreut wird. Beide Projekte unterscheiden sich jedoch wesentlich. LINQ ist in erster Linie ein Feature, dass direkt auf Objekten arbeitet wohingegen MySQL auf relationale Daten angewendet wird. Allerdings kann LINQ viel mehr als das.

LINQ kann als Layer und Bindeglied zwischen Collections aus Daten und den Programmiersprachen des .NET Frameworks betrachtet werden. Es ist hierbei m"oglich LINQ in verschiedenen Bereichen zu nutzen. Es arbeitet sowohl wie bereits erw"ahnt auf Collections aus Daten wie z.B. Listen aus Objekten die sich bereits im Hauptspeicher befinden oder fungiert als Bindeglied zu SQL um Daten aus einem Persistenten Medium auszulesen. Es kann aber auch dazu verwendet werden mit XML Datens"atzen bzw. Dokumenten zu arbeiten ist aber auch in der Lage mit Filesystemen und anderen Datenquellen zu interagieren. Das bedeutet dass LINQ sich nicht grunds"atzlich auf die vorher genannten M"oglichkeiten beschr"ankt sondern offen ist f"ur viele Arten von Daten. Weitere sind LINQ to DataSet und LINQ to SharePoint auf die hier mangels Relevanz zum Projekt nicht weiter eingegangen wird.

Diese Arbeit besch"aftigt sich also haupts"achlich mit dem LINQ Provider (LINQ Anbieter) LINQ to Objects da sich die zu verarbeitenden Daten w"ahrend der Bearbeitungszeit mit LINQ bereits im Speicher des Rechners befinden. Wie erw"ahnt, ist LINQ ein Layer f"ur die Programmiersprachen von .NET und kann deswegen nicht nur in \CSS verwendet werden wie hier, sondern auch in Microsofts VB.NET. Dieses Projekt beschr"ankt sich auf \CSS als Programmiersprache, weswegen auch alle folgenden Codebeispiele in \CSS geschrieben sind. Ein weiterer nicht zu verachtender Vorteil von LINQ im Gegensatz zu den meisten Implementationen von SQL Statements ist, dass die Statemtents vom \CSS compiler zum Zeitpunkt der Kompilierung auf syntaktische Korrektheit gepr"uft werden und der Benutzer vom IntelliSense System von Visual Studio wertvolle Hinweise w"ahrend der Generierung von LINQ Statements erh"alt.
		%Content
		\subsection {Was ist LINQ to Objects genau? }
		%Content
		LINQ to Objects wie in diesem Projekt verwendet, erfordert zur Benutzung erst einmal die grunds"atzliche Eigenschaft des Datensatzes eine Collection zu sein. Jede Collection aus Objekten auf die LINQ to objects angewendet wird muss also die Schnittstelle IEnumerable\GTS implementieren. Diese Objekte werden im LINQ Vokabular dann als Sequences bezeichnet. In dieser Arbeit werden fast aussschliesslich die generischen Collections von \CSS verwendet welche grunds"atzlich auch alle das generische IEnumerable\GTS Interface implementieren. Der am meisten verwendete Datentyp in dieser Arbeit ist die generischen Implementierung von List\GT.

Eine LINQ to object Abfrage besteht immer aus drei Abfrageoperationen
\begin{itemize}
\item Bereitstellen einer Datenquelle
\item Erstellen einer LINQ Abfrage
\item Ausführen der LINQ Abfrage auf der Datenquelle mithilfe einer foreach() Anweisung
\end{itemize}
Das besondere an der Formulierung von LINQ Statements ist, dass sie zum Zeitpunkt ihrer Erstellung noch keine Daten der Datenquelle abfragen sondern erst zum Ausf"uhrungszeitpunkt des Statements damit beginnen. Das ist sehr praktisch, denn dadurch k"onnen einmal in einer Abfrage erstellte Statements wiederverwertet werden. Eine LINQ Abfrage Variable speichert nie das Ergebnis einer Abfrage. Durch diesen Umstand ist es möglich, einen Datensatz zu unterschiedlichen Zeitpunkten abzufragen. Eventuell "andert sich auch das Ergebnis der Abfrage wenn man davon ausgeht dass sich die Collection der Daten "uber die Zeit ver"andert. Trotzdem wird immer nch die semantisch gleiche Abfrage verwendet. LINQ Abfragen werden also mit einer Verz"ogerung schlussendlich in einer foreach() Anweisung ausgef"uhrt. Dabei durchl"auft die foreach() Anweisung Syntaktisch die Query oder Statement variable und nicht die Collection der Daten.
\\
Hier folgt ein Beispiel welches eine einfache LINQ Abfrage auf einen einfachen Array Datensatz der IEnumerable\GTS implementiert darstellt.
\lstinputlisting
			[caption={LINQeasyQuery.cs - Einfaches LINQ Abfrage Beispiel}, label=code:linqeasyquery]
			{../Codebeispiele/LINQeasyQuery.cs}

Ein Statement kann jedoch auch erzwungen direkt ausgef"uhrt werden. Durch einen direkten Aufruf der Methoden toList\GTS oder toArray\GTS auf dem Statement.
%\caption[Foo Bar.]{Foo Bar. Redrawn from \protect\cite{Baz}.}
\lstinputlisting
			[caption={LINQdirectQueryList.cs - Einfaches direktes LINQ Abfrage Beispiel} \protect\cite{MicrosoftCReferenz.2013}, label=code:linqdirectquery]
			{../Codebeispiele/LINQdirectQueryList.cs}
		%Content
		\subsection {Abfragesyntax in LINQ}
		Was im vorigen Absatz als LINQ Statement bezeichnet wurde ist ein LINQ Statement geschrieben in der Abfragesyntax. Diese Syntax zeichnet sich durch einfache Lesbarkeit und einfache Zug"anglichkeit aus. Zur Kompilierzeit wird diese Syntax vom Compiler in die so genannte Methodensyntax "ubersetzt. Beide Methoden sind Semantisch identisch auch wenn sie sich auf den ersten Blick Syntaktisch sehr unterscheiden.
		%Content
		\subsection {Methodensyntax in LINQ}
		Die Methodensyntax in LINQ unterscheidet sich von der Abfragesyntax dadurch, dass anstatt fester keywords wie where, from und select um eine Abfrage zu formen Lambda Ausdr"ucke verwendet werden (Lambda Ausdr"ucke werden im n"achsten Abschnitt n"aher erleutert). In der Referenzdokumentation zu LINQ (Stand Juli 2013) \cite{MicrosoftCReferenz.2013} wird haupts"achlich diese Art der Syntax verwendet. Aus den dort aufgef"uhrten Typen wird in dieser Arbeit sehr h"aufig der Enumerable Typ verwendet.
\\
Hier ein Vergleich der beiden Syntaktischen M"oglichkeiten zum erstellen von LINQ Statements.
\lstinputlisting
			[caption={LINQzweiSynt.cs - Zwei syntaktische M"oglichkeiten} \protect\cite{MicrosoftCReferenz.2013}, label=code:linqzweisynt]
			{../Codebeispiele/LINQzweiSynt.cs}
		%Content
	\section {Einführung zu Lambda in \CS}
		%Content
		Lambda Ausdr"ucke in \CSS sind Anonymen Funktionen sehr "ahnlich. In dieser Arbeit wurden Lambda Ausdr"ucke haupts"achlich in LINQ Statemens verwendet. Syntaktisch ist diese Art Funktionen zu schreiben sehr simpel gestrickt. Das Lambda Zeichen in \CSS wird als \LAM dargestellt. Es folgt immer der Parameterliste und sollte nicht mit den Vergleichsoperatoren \textgreater = und \textless = verwechselt werden. Das Lamba Zeichen bedeutet hier soviel wie "`wechselt zu"' oder "`wird zu"' und steht Links des gew"unschten Ausdrucks.
		%Content
		\subsection {Lambda Ausdr"ucke in Verbindung mit LINQ}
Wie bereits beschrieben werden Lambda Ausdr"ucke  in verbindung mit LINQ in der Methodensyntax von LINQ verwendet. Diese Syntax wird meist benutzt um Standardabfrageoperatoren wie Collection.Select(lambda hier) Collection.Where(lambda hier) und Collection.All(lambda hier) zu verwenden. In dieser Arbeit wird der Standardoperator Select() am h"aufigsten verwendet. Select() wenden den angegebenen Lambda Ausdruck auf jedes Element der Collection an auf die der Select operator angewendet wird und gibt falls vorhanden ein Ergebnis zur"uck. Siehe Listing \ref{code:lambdaeasy}
\lstinputlisting
			[caption={LambdaEasy.cs - Einfacher Lambda Ausdruck}, label=code:lambdaeasy]
			{../Codebeispiele/LambdaEasy.cs}
%%%%%%
%	Einführung / Einleitung ENDE
%%%%%%



%%%%%%
%	Hauptteil START
%%%%%%

\chapter {Hauptteil}
	\section {Gegenüberstellung nativer (OpenMesh.org) und gemanagter Implementierungen der Half-Edge Data Structure}
		%Content	
		%Content
	\section {Geschwindigkeitsunterschiede von nativem und \CSS Code}
		%Content
		%Content
	\section {Die Vorteile in der Entwicklung von managed Code}
		%Content
		%Content
	\section {Das Software Projekt LINQ For Geometry (LFG)}
		%Content
		% Erweitert die Funktionen der HES zb durch normalen und vertex speichern in Face und Half-Edge
		%Content
		\subsection {Konzept zu \LFG}
			%Content
			%Content
			\subsubsection {Der Link von LINQ zur \HES}
				%Content
				%Content
		\subsection {Warum die Programmiersprache \CSS ?}
			%Content
			%Content
		\subsection {Furtwangen University Simulation and Entertainment Engine (FUSEE)}
			%Content
			%Content
	\section {Der Import von Geometriedaten im „Wavefront Object“ Format}
		%Content
		%Content
		\subsection {Warum das Wavefront Object Format}
			%Content
			%Content
		\subsection {Face basierter Import - Edge basiertes Handling}
			%Content
			%Content
		\subsection {Importer für das Wavefront Format}
			%Content
			%Content
	\section {Initialisierungsablauf}
			%Content
			%Content
		\subsection {UML Diagramme zum Initialisierungslauf}
				%Content
				%Content
	\section {Implementierung und Funktion der Handler für die einzelnen Komponenten der HES}
		\subsection {Beispiel eines Handler Konstruktes und seiner Implementierung}
		%Content
Die Handler Konstrukte "`Structs"' in dieser Arbeit, welcher Art auch immer, können vereinfacht gesagt als Zeiger auf Datens"atze von realen Daten betrachtet werden.
\lstinputlisting
			[caption={HandleHalf-Edge.cs - Variablen Deklaration des "`Zeigers"'}, label=code:hhezeiger, firstline=21, lastline=21]
			{../../HFU_FUSEE/Fusee/src/Engine/LinqForGeometry/LinqForGeometry.Core/src/Handles/HandleHalfEdge.cs}
Sie enthalten nur einen Index als Zeiger und sehr wenige Funktionen. Ein Handler speichert zur Laufzeit pro Instanz einen Index auf den realen Datensatz f"ur den er einen Handle darstellt. Handler Structs gibt es f"ur Edges, Half-Edges, Faces, FaceNormals, Vertices, VertexNormals und VertexUVs. Sie unterscheiden sich hierbei nur durch die Namensgebung der Structs und der Konstrukturen.
Ein Handler Struct stellt eine implizite Konvertierung des Handlers, siehe Listing \ref{code:hhecast}, in den Datentypen Integer (int) zur Verfügung.
\lstinputlisting
			[caption={HandleHalf-Edge.cs - Impliziter cast nach Integer}, label=code:hhecast, firstline=37, lastline=40]
			{../../HFU_FUSEE/Fusee/src/Engine/LinqForGeometry/LinqForGeometry.Core/src/Handles/HandleHalfEdge.cs}

Zus"atzlich kann der Entwickler jederzeit abfragen ob der aktuell verwendete Handler schon als valide betrachtet werden kann. Hierzu Listing \ref{code:isvalid} betrachten. Ein Handler ist dann valide, wenn sein Index nicht kleiner als 0 ist. In dieser Arbeit werden einstweilen Handler initialisiert f"ur die zum Zeitpunkt der Initialisierung noch kein Index zur Speicherung bereit steht. Diese vorerst nicht validen Handler werden dann mit dem Wert -1 initialisiert und sind somit zu diesem Zeitpunkt als nicht valide also nicht verwendbar zu betrachten. Um diese sp"ater im Programm zu benutzen, muss also noch der korrekte Index, meistens der Wert einer Count Funktion auf einer Liste eingef"ugt werden.
\lstinputlisting
			[caption={HandleHalf-Edge.cs - Is Valid?}, label=code:isvalid, firstline=45, lastline=48]
			{../../HFU_FUSEE/Fusee/src/Engine/LinqForGeometry/LinqForGeometry.Core/src/Handles/HandleHalfEdge.cs}

Eine Besonderheit der Handler ist die mit "`internal"' gekennzeichnete Deklaration der Indizes. Siehe hierzu Listing \ref{code:hheinternal}. Durch das "`internal"' \CSS Schl"usselwort k"onnen die Handler nur aus der jeweiligen gleichen Assembly angesprochen und ver"andert werden. Dies verhindert einen unbefugten oder unabsichtlichen Fremdzugriff von Au"sen. W"ahrend der Laufzeit wird also die Konsistenz der Datenstruktur in sich gesch"utzt um so das Programm vor Abst"urzen durch Zeiger Fehler zu sch"utzen.
\lstinputlisting
			[caption={HandleHalf-Edge.cs - Deklarationen als internal}, label=code:hheinternal, firstline=21, lastline=21]
			{../../HFU_FUSEE/Fusee/src/Engine/LinqForGeometry/LinqForGeometry.Core/src/Handles/HandleHalfEdge.cs}

\begin{quote}{\dq}Der interne Zugriff wird h{\"a}ufig in komponentenbasierter Entwicklung verwendet, da er einer Gruppe von Komponenten erm{\"o}glicht, in einer nicht {\"o}ffentlichen Weise zusammenzuwirken, ohne dem Rest des Anwendungscodes zug{\"a}nglich zu sein.{\dq} \cite{MicrosoftCReferenz.2013}\end{quote}


Die vollst"andige Implementierung dieses Structs und aller sieben weiteren kann im Visual Studio 2010 Projekt auf dem diese Arbeit aufbaut unter folgender Verzeichnisstruktur betrachtet werden. "`LinqForGeometry/LinqForGeometry.Core/src/Handles"'
		%Content

\section {Pointer Container und ihre Rolle in \LFG}
		%Content
		Pointer Container in \LFGS sind \CSS Structures und existieren f"ur jeden in der Datenstruktur essentiellen Datentypen und geh"oren zum Kern Projekt (LinqForGeometry.Core) des \LFGS Projekts. Zu den Containern z"ahlen Half-Edges Container, Edge container, Face Container und Vertex Container. Ein Pointer Container wird f"ur jeden Datensatz der in die Datenstruktur eingef"ugt wird initialisiert und in einer Liste gespeichert. Jeder Container enth"alt, den Spezifikationen der \HES folgend Handles auf andere eingepflegte oder in kurzer Zeit einzupflegende Datens"atze z.B. durch eine mathematische Operation (welche den voraussichtlichen Index eines einzuf"ugenden Datensatzes berechnet). Pointer Container sind sozusagen die Gebilde welche die Half-Edge Datenstruktur aufspannen und ihre Eigenschaften im Speicher vorhalten. M"ochte man ein gespeichertes Mesh transformieren so sind alle Operationen die vorgenommen werden "Anderungen an den Pointer Containern bzw. den in ihnen enthaltenen Daten. Pointer Container sind also die Basis des ganzen Programms. Durch die Gegebenheiten der Implementierung von List<T> (Generic Lists) in \CSS ist es leider nicht m"oglich die Container bei "Anderungen direkt in einer Liste zu manipulieren. Jeder Container muss erst aus der Liste kopiert werden um ihn dann zu "andern und anschliessen an der gleichen Stelle wieder einzuf"ugen. N"otig hierzu ist, dass der Index des Containers in der jeweiligen Liste bekannt ist. Hierzu ein kleines Beispiel welches die Erkl"arung etwas erl"autern soll.
\lstinputlisting
			[caption={PtrContExample1.cs - Manipulation eines Pointer Containers}, label=code:ptrcontmanip]
			{../Codebeispiele/PtrContExample1.cs}
		%Content
\subsection {Half-Edges Pointer-Container}
%Content
			Der Half-Edge Pointer Container, in \LFGS class HEdgePtrCont, speichert alle Informationen die laut \HES an einer Half-Edge anliegen m"ussen. Die zugeh"orige Datei im \LFGS Projekt ist "`HEdgePtrCont.cs"'.
\begin{itemize}
\item Ein HandleHalfEdge \_he; (auf die Twin Half-Edge)
\item Ein HandleHalfEdge \_nhe; (auf die n"achste Half-Edge im Uhrzeigersinn)
\item Ein HandleVertex \_v; (auf den Vertex auf den die Half-Edge zeigt)
\item Ein HandleFace \_f; (auf das zugeh"orige Face)
\end{itemize}

In der Implementierung von \LFGS werden an einer Half-Edge noch zus"atzliche Handler Informationen f"ur die Verwendung und Konvertierung des Meshes in und nach FUSEE gespeichert.

\begin{itemize}
\item HandleVertexNormal \_vn; (auf die Vertex Normale eines Vertex)
\item HandleVertexUV \_vuv; (auf die UV Texture Koordinaten eines Vertex)
\end{itemize}

Da jede Half-Edge auch eine Verbindung zum Vertex hat auf den sie zeigt ist es sehr praktisch an ihr auch die zus"atzlichen Informationen zu speichern die der Vertex in FUSEE ben"otigt. Es wird also ein Index auf die Vertex Normale im Speicher zum angesprochenen Vertex gespeichert. Zus"atzlich noch ein Index auf die UV Texture Koordinaten die f"ur den Vertex gelten. So kann die Iteration bei einer sp"ateren Konvertierung der Datenstruktur in ein f"ur FUSEE verst"andliches Mesh Objekt "uberhaupt erst m"oglich gemacht werden. Es w"are mit erheblichem Mehraufwand und wachsendem Speicherverbrauch auch m"oglich gewesen die Informationen an den einzelnen Vertices durch Verkn"upfungen mit Listen welche jeweils die die Daten f"ur einen Vertex speichernzu realisieren, allerdings h"atte das eine regelrechte Aufweichung der Idee der Datenstruktur bedeutet (alle wichtigen Informationen werden an den Half-Edges gespeichert). Zus"atzlich w"are es so wesentlich aufwendiger geworden eine korrekte Kanten und Winkel basierte Vertex Normalen Berechnung pro Vertex pro Face f"ur die in FUSEE vorhandene Beleuchtungsshader zu implementieren wie sie durch diese kleine erweiterung der \HES jetzt bereits in \LFGS vorhanden ist.
		\subsection {Edges Pointer-Container}
			%Content
			Ein Edge Pointer Container, in \LFG zu finden im Struct "`EdgePtrcont.cs"', ist ein Repr"asentation von Kanten in der \HES. Jeder Edge Pointer Container beinhaltet zwei Handles auf Half-Edges.
\begin{itemize}
\item HandleHalfEdge \_he1; (Handle auf die Erste Half-Edge eines Half-Edge Paares)
\item HandleHalfEdge \_he2; (Handle auf die Erste Half-Edge eines Half-Edge Paares)
\end{itemize}
Diese beiden Handles sind ein jeweils zusammengeh"origes Half-Edge Paar. Durch die bereitstellung dieser Edge Pointer Container ist zum Beispiel eine Selektierung von echten Kanten in einem 3D Editor denkbar. Sie dienen ebenfalls als Einstiegspunkt um manipulations Algorithmen auf das gespeicherte Mesh anzuwenden.
			%Content	
		\subsection {Vertices Pointer-Container}
			%Content
			Dadurch, dass in der Half-Edge Datenstruktur alle wichtigen Informationen bereits an jeder Half-Edge gespeichert werden, speichern Vertex Pointer Container lediglich einen Handle auf eine von ihm ausgehende Half-Edge. Da ein Vertex aber meistens mehrere ausgehende Half-Edges besitzt wird der Platz nach dem "first come first serve" Prinzip verteilt. Das bedeutet, dass nur die erste Half-Edge die w"ahrend des Initialisierungslauf an den Vertex angelegt wird an dieser Stelle auch referenziert wird. Durch diesen Handle k"onnen Iteratoren sehr einfach realisiert werden die in anderen Datenstrukturen wie der Face basierten Datenstruktur einiges an Mehraufwand bedeuten w"urden. Als Beispiel soll hier der Sternumlauf Iterator genannt werden. Dieser kann alle eingehenden oder ausgehenden Half-Edges zu einem gegebenen Vertex bestimmen. Hier dargestellt kurz der Ablauf des Iterators f"ur eingehende Half-Edges:
\begin{enumerate}
\item Es wird ein Vertex als Startpunkt erwartet
\item Es wird die ausgehende Half-Edge des Vertex angesprochen (und den Index merkt sich der Algorithmus als Determinante)
\item Es wird die Twin Half-Edge der eben geholten Half-Edge angesprochen
\item Die Twin Half-Edge wird als erste eingehende Half-Edge im Ergebnis Set zwischengespeichert
\item Zu dieser Half-Edge wird jetzt die "`Next"' Half-Edge angesprochen.
\item Ihre Twin Half-Edge ist nun wieder eine eingehende Half-Edge.
\item Ab jetzt wird der Algorithmus ab Schritt 3 wiederholt bis man als Index einer n"achsten Half-Edge die zuvor gespeicherte Determinante erreicht.
\end{enumerate}

So ist es mit ein paar Pointer Spr"ungen m"oglich diesen Algorithmus schnell und effizient durchzuf"uhren. In einer Face basierten Datenstruktur w"are eine solche Operation wegen der fehlenden Beziehungen und Vernetzungen ohne massive "Anderungen der Strukur kaum m"oglich.
			%Content
		\subsection {Faces Pointer-Container}
			%Content
			Laut Definition der \HES speichert ein Face jeweils einen Zeiger auf eine ihm angeh"orige Half-Edge. In \LFG wurde genau das in der Implementierung umgesetzt. Das erleichtert den Einstieg in manipulations Algorithmen wenn der Startpunkt f"ur diese als Face gegeben ist. So ist es einfach die Grenzen (Boundaries) eines Faces und z.B. die das Face umspannenenden Half-Edges, Edges, Vertices oder sogar die benachbarten Faces herauszufinden. \LFGS stellt in seiner Implementierung all diese Iteratoren zur Verf"ugung um damit weitere Algorithmen zu entwerfen.

\begin{itemize}
\item HandleHalfEdge \_h;
\end{itemize}

Zus"atzlich zu den Standards der \HES bietet \LFGS die M"oglichkeit an jedem Face ein Handle auf eine dem Face zugeh"orige Face Normale zu speichern. Diese Face Normale gibt die Richtung des Faces an sollte die Datenstruktur in eine 3D Engine implementiert werden in welcher Backface Culling unterst"utzt und dabei Normalen als Ausrichtungsmerkmal beachtet werden. In \LFG und seiner Implementierung in der FUSEE Engine wird die Face Normale aktuell nur zur Berechnung der Vertex Normalen herangezogen. FUSEE ben"otigt f"ur das Backface Culling lediglich eine Traversierung der Polygone entgegen des Uhrzeigersinns. Diese Besonderheit tritt in Engines auf welche OpenGL als Grafikschnittstelle verwenden.
\begin{itemize}
\item HandleFaceNormal \_fn;
\end{itemize}
			%Content
	\section {Die Geometrie in LINQ For Geometry}
		%Content
			Hier Information über das Geometry Objekt und die darin enthaltenen Daten etc.
		%Content
		\subsection {Benchmarks zu Laufzeiten des Programms}
			%Content
			%Content
	\section {Anwendungsfälle von LINQ For Geometry}
		%Content
		%Content
		\subsection {\LFGS als Editor Datenstruktur in FUSEE}
			%Content
			%Content
	\section {LINQ und Lambda Ausdrücke und ihre Stärken und Schwächen bei der Selektierung großer Datenmengen}
		%Content
	\section {Stern- und Umlaufenumeratoren (Iteratoren)}
		%Content
		%Content
		\subsection {Die Geschwindigkeit der Half-Edge Datenstruktur in den Enumeratoren}
			%Content
			%Content
		\subsection {Verwendete „Design-Patterns“ und Softwarelösungen}
			%Content
			%Content
		\subsection {LINQ und Lambda Ausdrücke in den Enumeratoren}
			%Content
			%Content
		\subsection {Unterschiedliche Iteratoren kurz dargestellt}
			%Content
			%Content
	\section {Manipulation von Mesh Daten in der Datenstruktur}
		%Content
		%Content
		\subsection {Manipulation von Vertices}
			%Content
			%Content
		\subsection {Manipulation von Edges und Half-Edges}
			%Content
			%Content
		\subsection {Manipulation von Faces}
			%Content
			%Content
	\section {Beispielhafte Implementierung von Standard Algorithmen zur Geometriemanipulation als Modul}
			%Content
			%Content
	\section {Implementierung von Catmull Clark als Modul f"ur \LFG}
			%Content
			%Content
		\subsection {Was ist der Catmull Clark Algorithmus?}
				%Content
				%Content
		\subsection {Vorteile der Implementierung in der HES}
				%Content
				%Content

%%%%%%
%	Hauptteil ENDE
%%%%%%



%%%%%%
%	Schluss START
%%%%%%

\chapter {Schluss}
	\section {Ergebnis der Arbeit}
		%Content
		\subsection {Der aktuelle Status von \LFG}
			%Content
			% Spielraum für Verbesserungen, Beleuchtung, Konvertierung in FUSEE Mesh, Kanten mit mehr als 2 Faces möglich aber nicht schön, etc.
			\subsubsection {Welche M"oglichkeiten zur Erweiterung durch eigenen Code bietet \LFG}
				%Content
				% Module, zb das Transformationsmodul. Zusätzlich schauen ob man sagen kann das Catmull Clark als Modul läuft etc.
	\section {Zukünftige Entwicklungen und Ausblick auf die Verwendung von \LFG}
		%Content

%%%%%%
%	Schluss ENDE
%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inhalt ENDE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part*{Appendix}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source Code Verzeichnis START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstlistoflistings
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source Code Verzeichnis ENDE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bilbiographie START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{Citavi}
\addcontentsline{toc}{chapter}{Literaturverzeichnis}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bilbiographie ENDE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}