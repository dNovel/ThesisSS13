\documentclass[12pt,a4paper]{scrreprt}
\usepackage[a4paper, left=3cm, right=3cm, top=2cm, bottom=2cm]{}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{setspace}
\usepackage{color}
\usepackage{cite} % Paket fuer die Zitation
%\usepackage{sourcesanspro}
% Paket fuer das anzeigen von Quellcode
\usepackage{listings}
% Setze die Programmiersprache auf CSharp
\lstset{language=[Sharp]C} 

% Festlegung Art der Zitierung - Havardmethode: Abkuerzung Autor + Jahr
\bibliographystyle{plain}

% Festlegen der Sprache
\selectlanguage{german}

% Settings fuer den Sourcecode START
\definecolor{mygreen}{rgb}{0,0.4,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{bggray}{rgb}{0.97,0.97,0.97}

\lstset{
backgroundcolor=\color{bggray},  % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\scriptsize, % the size of the fonts that are used for the code
breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
breaklines=true,                 % sets automatic line breaking
captionpos=b,                    % sets the caption-position to bottom
commentstyle=\color{mygreen},    % comment style
deletekeywords={...},            % if you want to delete keywords from the given language
escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single,                    % adds a frame around the code
keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue},       % keyword style
language=[Sharp]C,                 % the language of the code
morekeywords={*,Select},            % if you want to add more keywords to the set
numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt,                   % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false,          % underline spaces within strings only
showtabs=false,                  % show tabs within strings adding particular underscores
stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve},     % string literal style
tabsize=2,                       % sets default tabsize to 2 spaces
title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
captionpos=t,
%morecomment=[il]{///}
}
% Settings fuer den Sourcecode ENDE


% Authoren
\author{
Dominik Steffen \and
Erstbetreuer: Prof. Christoph Müller, Fakultät DM \and
Zweitbetreuer: Prof. Wilhelm Walter, Fakultät DM
}



% Titel
\title{LINQ for Geometry}
\subtitle{Implementierung der Half-Edge Datenstruktur zu Manipulation und Handling Dreidimensionaler Meshes insbesondere durch den Einsatz von LINQ und LAMBA Ausdrücken in Microsofts \CS}



\parindent 0pt



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Commands START - Makros
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% C# makro OHNE space nach dem logo
\newcommand{\CS}{C\texttt{\#}}
% C# makro MIT space nach dem logo
\newcommand{\CSS}{C\texttt{\# }}
% C++ Logo
\newcommand{\CPP}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
% LINQ For Geometry
\newcommand{\LFG}{LINQ For Geometry}
% LINQ For Geometry mit Space
\newcommand{\LFGS}{LINQ For Geometry }
% Generic zeichen <T>
\newcommand{\GT}{\textless T\textgreater}
\newcommand{\GTS}{\textless T\textgreater\space}
% Lambda Zeichen in C#
\newcommand{\LAM}{ =\textgreater\space}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Commands ENDE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\makeindex
\onehalfspacing

\begin{document}
% Titelblatt START
\maketitle
\newpage
% Titelblatt ENDE

% Inhaltsverzeichnis START
\begingroup
	\clearpage
	\pagestyle{empty}
	\renewcommand*{\chapterpagestyle}{empty}
	\tableofcontents
	\clearpage
\endgroup
% Inhaltsverzeichnis ENDE

% Passe Seitenzahlen wieder an START
\pagestyle{plain}
\setcounter{page}{1}
% Passe Seitenzahlen wieder an ENDE



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inhalt START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%
% Strukturierung der Thesis in vorläufiger Form
%%%%%%%%%%



%%%%%%
%	Einführung / Einleitung START
%%%%%%

\chapter {Einleitung}
	\section {Fragestellung}
		Ist es möglich die „Half-Edge Data Structure“ (kurz HES) in einer gemanagten Programmiersprache wie \CSS unter der Berücksichtigung von LINQ und Lambda Ausdrücken so zu implementueren, dass damit grundlegende Geometriemanipulation in der Computergrafik erfolgen kann?
	\section {Anforderungen und Ziele}
	%Content
	
	%Content
	\section {Die Half-Edge Data Structure (kurz HES) als Algorithmus}
		%Content
		% Mark de Berg, Otfried Cheong, Marc van Kreveld, Mark Overmars: Computational Geometry: Algorithms and Applications. Springer-Verlag Berlin Heidelberg New York, 2000, ISBN 3-540-65620-0, S. 31–32
		\subsection {Die Basis der HES}
			%Content
			%TODO Planare Graphen erkläutern und verstehen
			\subsubsection {Verbindungen und Beziehungen in der HES}
			%Content
			\subsubsection {Doubly Connected Edge List}
			Die doubly connected edge list (kurz DECL) ist der verwendeten HES nicht unähnlich. Beide Datenstrukturen ähneln sich immens und haben doch ein paar wenige entscheidende Unterschiede. TODO % Eher genau gleich?
			%Content
		\subsection {Speicherverbrauch im Gegensatz zu Face basierten Lösungen}
			%Content
			% TODO, höherer verbrauch, aber gleichzeit auch wesentlich flexibler. Speicher ist vorhanden, geschwindigkeit wird gesucht als ziel
		\subsection {Vorteile der HES}
			%Content
			%TODO rasche geschwindigkeit in iterationen. Beispiel für einen Algorithmus anführen der Kanten eines Polygons sucht oder sonstwie über ein Polygon iteriert.
	\section {Aktueller Forschungsstatus}
		%Content
		\subsection {Probleme der aktuellen Forschung}
			%Content
	\section {Einführung zu LINQ in \CS}
		%Content
		Language Integrated Query, kurz LINQ und zu deutsch Sprachintegrierte Abfrage,funktioniert ab \CSS 3.0 und ist ein Feature von Microsofts .NET Paket. LINQ ist also ein Produkt von Microsoft und erinnert auf den ersten Blick in seinem syntaktischen und semantischem Aufbau stark an das Open Source Projekt MySQL welches aktuell (Stand Juli 2013) von der Oracle Corporation betreut wird. Beide Projekte unterscheiden sich jedoch wesentlich. LINQ ist in erster Linie ein Feature, dass direkt auf Objekten arbeitet wohingegen MySQL auf relationale Daten angewendet wird. Allerdings kann LINQ viel mehr als das. LINQ kann als Layer und Bindeglied zwischen Collections aus Daten und den Programmiersprachen des .NET Frameworks betrachtet werden. Es ist hierbei m"oglich LINQ in verschiedenen Bereichen zu nutzen. Es arbeitet sowohl wie bereits erw"ahnt auf Collections aus Daten wie z.B. Listen aus Objekten die sich bereits im Hauptspeicher befinden oder fungiert als Bindeglied zu SQL um Daten aus einem Persistenten Medium auszulesen. Es kann aber auch dazu verwendet werden mit XML Datens"atzen bzw. Dokumenten zu arbeiten ist aber auch in der Lage mit Filesystemen und anderen Datenquellen zu interagieren. Das bedeutet dass LINQ sich nicht grunds"atzlich auf die vorher genannten M"oglichkeiten beschr"ankt sondern offen ist f"ur viele Arten von Daten. Weitere sind LINQ to DataSet und LINQ to SharePoint auf die hier mangels Relevanz zum Projekt nicht weiter eingegangen wird. Diese Arbeit besch"aftigt sich also haupts"achlich mit dem LINQ Provider (LINQ Anbieter) LINQ to Objects da sich die zu verarbeitenden Daten w"ahrend der Bearbeitungszeit mit LINQ bereits im Speicher des Rechners befinden. Wie erw"ahnt, ist LINQ ein Layer f"ur die Programmiersprachen von .NET und kann deswegen nicht nur in \CSS verwendet werden wie hier, sondern auch in Microsofts VB.NET. Dieses Projekt beschr"ankt sich auf \CSS als Programmiersprache, weswegen auch alle folgenden Codebeispiele in \CSS geschrieben sind. Ein weiterer nicht zu verachtender Vorteil von LINQ im Gegensatz zu den meisten Implementationen von SQL Statements ist, dass die Statemtents vom \CSS compiler zum Zeitpunkt der Kompilierung auf syntaktische Korrektheit gepr"uft werden und der Benutzer vom IntelliSense System von Visual Studio wertvolle Hinweise w"ahrend der Generierung von LINQ Statements erh"alt.
		%Content
		\subsection {Was ist LINQ to Objects genau? }
		%Content
		LINQ to Objects wie in diesem Projekt verwendet, erfordert zur Benutzung erst einmal die grunds"atzliche Eigenschaft des Datensatzes eine Collection zu sein. Jede Collection aus Objekten auf die LINQ to objects angewendet wird muss also die Schnittstelle IEnumerable\GTS implementieren. Diese Objekte werden im LINQ Vokabular dann als Sequences bezeichnet. In dieser Arbeit werden fast aussschliesslich die generischen Collections von \CSS verwendet welche grunds"atzlich auch alle das generische IEnumerable\GTS Interface implementieren. Der am meisten verwendete Datentyp in dieser Arbeit ist die generischen Implementierung von List\GT.
\\
Eine LINQ to object Abfrage besteht immer aus drei Abfrageoperationen
\begin{itemize}
\item Bereitstellen einer Datenquelle
\item Erstellen einer LINQ Abfrage
\item Ausführen der LINQ Abfrage auf der Datenquelle mithilfe einer foreach() Anweisung
\end{itemize}
Das besondere an der Formulierung von LINQ Statements ist, dass sie zum Zeitpunkt ihrer Erstellung noch keine Daten der Datenquelle abfragen sondern erst zum Ausf"uhrungszeitpunkt des Statements damit beginnen. Das ist sehr praktisch, denn dadurch k"onnen einmal in einer Abfrage erstellte Statements wiederverwertet werden. Eine LINQ Abfrage Variable speichert nie das Ergebnis einer Abfrage. Durch diesen Umstand ist es möglich, einen Datensatz zu unterschiedlichen Zeitpunkten abzufragen. Eventuell "andert sich auch das Ergebnis der Abfrage wenn man davon ausgeht dass sich die Collection der Daten "uber die Zeit ver"andert. Trotzdem wird immer nch die semantisch gleiche Abfrage verwendet. LINQ Abfragen werden also mit einer Verz"ogerung schlussendlich in einer foreach() Anweisung ausgef"uhrt. Dabei durchl"auft die foreach() Anweisung Syntaktisch die Query oder Statement variable und nicht die Collection der Daten.
\\
Hier folgt ein Beispiel welches eine einfache LINQ Abfrage auf einen einfachen Array Datensatz der IEnumerable\GTS implementiert darstellt.
\lstinputlisting
			[caption={LINQeasyQuery.cs - Einfaches LINQ Abfrage Beispiel}, label=code:linqeasyquery]
			{../Codebeispiele/LINQeasyQuery.cs}

Ein Statement kann jedoch auch erzwungen direkt ausgef"uhrt werden. Durch einen direkten Aufruf der Methoden toList\GTS oder toArray\GTS auf dem Statement.
%\caption[Foo Bar.]{Foo Bar. Redrawn from \protect\cite{Baz}.}
\lstinputlisting
			[caption={LINQdirectQueryList.cs - Einfaches direktes LINQ Abfrage Beispiel} \protect\cite{MicrosoftCReferenz.2013}, label=code:linqdirectquery]
			{../Codebeispiele/LINQdirectQueryList.cs}
		%Content
		\subsection {"`Abfragesyntax"' in LINQ}
		Was im vorigen Absatz als LINQ Statement bezeichnet wurde ist ein LINQ Statement geschrieben in der Abfragesyntax. Diese Syntax zeichnet sich durch einfache Lesbarkeit und einfache Zug"anglichkeit aus. Zur Kompilierzeit wird diese Syntax vom Compiler in die so genannte Methodensyntax "ubersetzt. Beide Methoden sind Semantisch identisch auch wenn sie sich auf den ersten Blick Syntaktisch sehr unterscheiden.
		%Content
		\subsection {"`Methodensyntax"' in LINQ}
		Die Methodensyntax in LINQ unterscheidet sich von der Abfragesyntax dadurch, dass anstatt fester keywords wie where, from und select um eine Abfrage zu formen Lambda Ausdr"ucke verwendet werden (Lambda Ausdr"ucke werden im n"achsten Abschnitt n"aher erleutert). In der Referenzdokumentation zu LINQ (Stand Juli 2013) \cite{MicrosoftCReferenz.2013} wird haupts"achlich diese Art der Syntax verwendet. Aus den dort aufgef"uhrten Typen wird in dieser Arbeit sehr h"aufig der Enumerable Typ verwendet.
\\
Hier ein Vergleich der beiden Syntaktischen M"oglichkeiten zum erstellen von LINQ Statements.
\lstinputlisting
			[caption={LINQzweiSynt.cs - Zwei syntaktische M"oglichkeiten} \protect\cite{MicrosoftCReferenz.2013}, label=code:linqzweisynt]
			{../Codebeispiele/LINQzweiSynt.cs}
		%Content
	\section {Einführung zu Lambda in \CS}
		%Content
		Lambda Ausdr"ucke in \CSS sind Anonymen Funktionen sehr "ahnlich. In dieser Arbeit wurden Lambda Ausdr"ucke haupts"achlich in LINQ Statemens verwendet. Syntaktisch ist diese Art Funktionen zu schreiben sehr simpel gestrickt. Das Lambda Zeichen in \CSS wird als \LAM dargestellt. Es folgt immer der Parameterliste und sollte nicht mit den Vergleichsoperatoren \textgreater = und \textless = verwechselt werden. Das Lamba Zeichen bedeutet hier soviel wie "`wechselt zu"' oder "`wird zu"' und steht Links des gew"unschten Ausdrucks.
		%Content
		\subsection {Lambda Ausdr"ucke in Verbindung mit LINQ}
Wie bereits beschrieben werden Lambda Ausdr"ucke  in verbindung mit LINQ in der Methodensyntax von LINQ verwendet. Diese Syntax wird meist benutzt um Standardabfrageoperatoren wie Collection.Select(lambda hier) Collection.Where(lambda hier) und Collection.All(lambda hier) zu verwenden. In dieser Arbeit wird der Standardoperator Select() am h"aufigsten verwendet. Select() wenden den angegebenen Lambda Ausdruck auf jedes Element der Collection an auf die der Select operator angewendet wird und gibt falls vorhanden ein Ergebnis zur"uck. Siehe Listing \ref{code:lambdaeasy}
\lstinputlisting
			[caption={LambdaEasy.cs - Einfacher Lambda Ausdruck}, label=code:lambdaeasy]
			{../Codebeispiele/LambdaEasy.cs}

%%%%%%
%	Einführung / Einleitung ENDE
%%%%%%



%%%%%%
%	Hauptteil START
%%%%%%

\chapter {Hauptteil}
	\section {Gegenüberstellung nativer (OpenMesh.org) und gemanagter Implementierungen der Half-Edge Data Structure}
		%Content	
		%Content
	\section {Geschwindigkeitsunterschiede von nativem und \CSS Code}
		%Content
		%Content
	\section {Die Vorteile in der Entwicklung von managed Code}
		%Content
		%Content
	\section {Das Software Projekt LINQ For Geometry (LFG)}
		%Content
		%Content
		\subsection {Warum die Programmiersprache \CSS ?}
			%Content
			%Content
		\subsection {Furtwangen University Simulation and Entertainment Engine (FUSEE)}
			%Content
			%Content
		\subsection {Grober Ablauf einer HES Initialisierung}
			%Content
			%Content
			\subsubsection {UML Diagramme zum Initialisierungslauf}
				%Content
				%Content
	\section {Der Import von Geometriedaten im „Wavefront Object“ Format}
		%Content
		%Content
		\subsection {Warum das Wavefront Object Format}
			%Content
			%Content
			\subsubsection {Face basierter Import - Edge basiertes Handling}
				%Content
				%Content
		\subsection {Importer für das Wavefront Format}
			%Content
			%Content
	\section {Implementierung und Funktion der Handler für die einzelnen Komponenten der HES}
		\subsection {Beispiel eines Handler Konstruktes und seiner Implementierung}
		%Content
Die Handler Konstrukte "`Structs"' in dieser Arbeit, welcher Art auch immer, können vereinfacht gesagt als Zeiger auf Datens"atze von realen Daten betrachtet werden.
\lstinputlisting
			[caption={HandleHalf-Edge.cs - Variablen Deklaration des "`Zeigers"'}, label=code:hhezeiger, firstline=21, lastline=21]
			{../../HFU_FUSEE/Fusee/src/Engine/LinqForGeometry/LinqForGeometry.Core/src/Handles/HandleHalfEdge.cs}
Sie enthalten nur einen Index als Zeiger und sehr wenige Funktionen. Ein Handler speichert zur Laufzeit pro Instanz einen Index auf den realen Datensatz f"ur den er einen Handle darstellt. Handler Structs gibt es f"ur Edges, Half-Edges, Faces, FaceNormals, Vertices, VertexNormals und VertexUVs. Sie unterscheiden sich hierbei nur durch die Namensgebung der Structs und der Konstrukturen.
Ein Handler Struct stellt eine implizite Konvertierung des Handlers, siehe Listing \ref{code:hhecast}, in den Datentypen Integer (int) zur Verfügung.
\lstinputlisting
			[caption={HandleHalf-Edge.cs - Impliziter cast nach Integer}, label=code:hhecast, firstline=37, lastline=40]
			{../../HFU_FUSEE/Fusee/src/Engine/LinqForGeometry/LinqForGeometry.Core/src/Handles/HandleHalfEdge.cs}

Zus"atzlich kann der Entwickler jederzeit abfragen ob der aktuell verwendete Handler schon als valide betrachtet werden kann. Hierzu Listing \ref{code:isvalid} betrachten. Ein Handler ist dann valide, wenn sein Index nicht kleiner als 0 ist. In dieser Arbeit werden einstweilen Handler initialisiert f"ur die zum Zeitpunkt der Initialisierung noch kein Index zur Speicherung bereit steht. Diese vorerst nicht validen Handler werden dann mit dem Wert -1 initialisiert und sind somit zu diesem Zeitpunkt als nicht valide also nicht verwendbar zu betrachten. Um diese sp"ater im Programm zu benutzen, muss also noch der korrekte Index, meistens der Wert einer Count Funktion auf einer Liste eingef"ugt werden.
\lstinputlisting
			[caption={HandleHalf-Edge.cs - Is Valid?}, label=code:isvalid, firstline=45, lastline=48]
			{../../HFU_FUSEE/Fusee/src/Engine/LinqForGeometry/LinqForGeometry.Core/src/Handles/HandleHalfEdge.cs}

Eine Besonderheit der Handler ist die mit "`internal"' gekennzeichnete Deklaration der Indizes. Siehe hierzu Listing \ref{code:hheinternal}. Durch das "`internal"' \CSS Schl"usselwort k"onnen die Handler nur aus der jeweiligen gleichen Assembly angesprochen und ver"andert werden. Dies verhindert einen unbefugten oder unabsichtlichen Fremdzugriff von Au"sen. W"ahrend der Laufzeit wird also die Konsistenz der Datenstruktur in sich gesch"utzt um so das Programm vor Abst"urzen durch Zeiger Fehler zu sch"utzen.
\lstinputlisting
			[caption={HandleHalf-Edge.cs - Deklarationen als internal}, label=code:hheinternal, firstline=21, lastline=21]
			{../../HFU_FUSEE/Fusee/src/Engine/LinqForGeometry/LinqForGeometry.Core/src/Handles/HandleHalfEdge.cs}

\begin{quote}{\dq}Der interne Zugriff wird h{\"a}ufig in komponentenbasierter Entwicklung verwendet, da er einer Gruppe von Komponenten erm{\"o}glicht, in einer nicht {\"o}ffentlichen Weise zusammenzuwirken, ohne dem Rest des Anwendungscodes zug{\"a}nglich zu sein.{\dq} \cite{MicrosoftCReferenz.2013}\end{quote}


Die vollst"andige Implementierung dieses Structs und aller sieben weiteren kann im Visual Studio 2010 Projekt auf dem diese Arbeit aufbaut unter folgender Verzeichnisstruktur betrachtet werden. "`LinqForGeometry/LinqForGeometry.Core/src/Handles"'
		%Content

\section {Pointer Container und ihre Rolle in \LFG}
		%Content
		%Content
		\subsection {Half-Edges Pointer-Container}
			%Content

			%Content
			\subsubsection {Vertex Normal Handler}
				%Content
			
				%Content
			\subsubsection {Vertex UV Handler}
				%Content

				%Content
		\subsection {Edges Pointer-Container}
			%Content

			%Content	
		\subsection {Vertices Pointer-Container}
			%Content

			%Content
		\subsection {Faces Pointer-Container}
			%Content

			%Content
	\section {Der Geometry Teil in LINQ For Geometry}
		%Content
			Hier Information über das Geometry Objekt und die darin enthaltenen Daten etc.
		%Content
		\subsection {Benchmarks zu Laufzeiten des Programms}
			%Content
			%Content
	\section {Anwendungsfälle von LINQ For Geometry}
		%Content
		%Content
		\subsection {\LFGS als Editor Datenstruktur in FUSEE}
			%Content
			%Content
	\section {LINQ und Lambda Ausdrücke und ihre Stärken und Schwächen bei der Selektierung großer Datenmengen}
		%Content
	\section {Stern- und Umlaufenumeratoren (Iteratoren)}
		%Content
		%Content
		\subsection {Die Geschwindigkeit der Half-Edge Datenstruktur in den Enumeratoren}
			%Content
			%Content
		\subsection {Verwendete „Design-Patterns“ und Softwarelösungen}
			%Content
			%Content
		\subsection {LINQ und Lambda Ausdrücke in den Enumeratoren}
			%Content
			%Content
		\subsection {Unterschiedliche Iteratoren kurz dargestellt}
			%Content
			%Content
	\section {Manipulation von Mesh Daten in der Datenstruktur}
		%Content
		%Content
		\subsection {Manipulation von Vertices}
			%Content
			%Content
		\subsection {Manipulation von Edges und Half-Edges}
			%Content
			%Content
		\subsection {Manipulation von Faces}
			%Content
			%Content
		\subsection {Beispielhafte Implementierung von Standard Algorithmen zur Geometriemanipulation als Modul}
			%Content
			%Content
		\subsection {Implementierung von Catmull Clark als Modul f"ur \LFG}
			%Content
			%Content
			\subsubsection {Was ist der Catmull Clark Algorithmus?}
				%Content
				%Content
			\subsubsection {Vorteile der Implementierung in der HES}
				%Content
				%Content

%%%%%%
%	Hauptteil ENDE
%%%%%%



%%%%%%
%	Schluss START
%%%%%%

\chapter {Schluss}
	\section {Ergebnis der Arbeit}
		%Content
		\subsection {Wie weit ist \LFGS fortgeschritten}
			%Content
		\subsection {Welche M"oglichkeiten zur Erweiterung durch eigenen Code bietet \LFG}
			%Content
	\section {Zukünftige Entwicklungen und Ausblick auf die Verwendung von \LFG}
		%Content

%%%%%%
%	Schluss ENDE
%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inhalt ENDE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source Code Verzeichnis START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstlistoflistings
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source Code Verzeichnis ENDE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bilbiographie START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{Citavi}
\addcontentsline{toc}{chapter}{Literaturverzeichnis}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bilbiographie ENDE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}